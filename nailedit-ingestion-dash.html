<!doctype html>
<html>
    <head>
        <title>NailedIT Ingestion API Dashboard</title>
        <meta charset="UTF-8" />
        <meta http-equiv="Access-Control-Allow-Origin" content="*" />
        <style>
            body {
                font-family: Arial, sans-serif;
                margin: 20px;
                background-color: #f8ece4; /* Page background color */
            }
            #app-container {
                max-width: 1200px;
                margin: 0 auto;
                background-color: #fff;
                padding: 20px;
                border-radius: 8px;
                box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3); /* Darker backdrop shadow */
            }
            h1 {
                color: #333;
                text-align: center;
                border-bottom: 1px solid #eee;
                padding-bottom: 10px;
                margin-bottom: 20px;
            }
            h2 {
                color: #333;
                margin: 0;
                font-size: 1.1em;
                padding: 0;
            }

            /* --- Top Controls Layout --- */
            #top-controls {
                display: flex;
                gap: 20px; /* Space between columns */
                flex-wrap: wrap; /* Allow wrapping */
                margin-bottom: 20px;
                align-items: flex-start; /* Align items to the top */
            }
            #top-controls > div {
                flex: 1 1 calc(50% - 10px); /* Basis 50% minus half gap */
                min-width: 300px; /* Prevent getting too narrow */
            }

            summary {
                cursor: pointer;
                font-weight: bold;
                padding: 10px;
                background-color: #f9f9f9;
                border: 1px solid #eee;
                border-radius: 4px;
                margin-bottom: 10px;
                list-style: none; /* Hide default marker */
                display: flex;
                align-items: center;
                gap: 8px;
            }
            summary::before {
                /* Custom disclosure marker */
                content: "►";
                font-size: 0.8em;
                line-height: 1;
            }
            details[open] summary::before {
                content: "▼";
            }

            details > div {
                padding: 15px;
                border: 1px solid #eee;
                border-top: none;
                border-radius: 0 0 4px 4px;
                margin-top: -11px; /* Overlap with summary border */
                margin-bottom: 20px;
            }

            #main-content {
                display: flex;
                gap: 20px;
                flex-wrap: wrap;
            }
            #main-content > details {
                flex: 1 1 calc(50% - 10px);
                min-width: 300px;
                box-sizing: border-box;
            }

            label {
                display: block;
                margin-bottom: 5px;
                font-weight: bold;
                color: #555;
            }
            input[type="text"],
            input[type="password"],
            input[type="url"],
            select,
            button {
                padding: 8px;
                margin-bottom: 10px;
                border: 1px solid #ccc;
                border-radius: 3px;
                width: 100%;
                box-sizing: border-box;
            }
            button {
                background-color: #6700d4; /* Button color */
                color: white;
                cursor: pointer;
                border: none;
                width: auto;
                padding: 10px 15px;
                margin-right: 5px;
                margin-top: 5px;
                width: 100%;
            }
            button:hover:not(:disabled) {
                background-color: #5200a3; /* Slightly darker hover */
            }
            button:disabled {
                background-color: #ccc;
                cursor: not-allowed;
            }
            .form-group {
                margin-bottom: 15px;
            }
            .form-group small {
                display: block;
                font-size: 0.85em;
                color: #666;
                margin-top: -5px;
                margin-bottom: 10px;
            }
            .optional-label {
                font-weight: normal;
                font-size: 0.9em;
                color: #777;
            }
            hr {
                border: none;
                border-top: 1px solid #eee;
                margin: 20px 0;
            }

            #status-indicator {
                position: fixed;
                top: 15px;
                right: 15px;
                padding: 8px 15px;
                background-color: rgba(0, 0, 0, 0.7);
                color: white;
                border-radius: 5px;
                z-index: 1000;
                display: none; /* Hidden by default */
                font-size: 1.1em;
                transition: opacity 0.3s ease-in-out;
                opacity: 0; /* Hidden by default */
            }
            #status-indicator.visible {
                display: block;
                opacity: 1;
            }
            #status-indicator.error {
                background-color: rgba(220, 53, 69, 0.8); /* Red for errors */
            }
            #bucket-selection-controls button {
                width: 100%;
                margin-top: 5px;
                margin-bottom: 5px;
            }
        </style>
    </head>
    <body>
        <div id="app-container">
            <h1>✨ NailedIT Ingestion API Dashboard ✨</h1>

            <!-- Top Controls: API Base URL, Key and Bucket Selection -->
            <div id="top-controls">
                <div class="form-group">
                    <label for="apiKeyInput">API Key:</label>
                    <input type="text" id="apiKeyInput" placeholder="Enter your X-API-Key" value="" />
                    <small>This key will be used for all API requests.</small>

                    <label for="apiBaseUrlInput" style="margin-top: 10px">API Base URL:</label>
                    <input
                        type="url"
                        id="apiBaseUrlInput"
                        placeholder="Enter the API base URL (e.g., https://...)"
                        value=""
                    />
                    <small>The root URL of the NailedIT API.</small>
                </div>
                <div class="form-group" id="bucket-selection-controls">
                    <label for="bucketConnectionSelect">Select a Bucket Connection:</label>
                    <select id="bucketConnectionSelect" disabled>
                        <option value="">-- Enter API Key & Base URL First --</option>
                    </select>
                    <button id="refreshConnectionsBtn" disabled>Refresh Connections</button>
                    <button id="removeConnectionBtn" disabled>Remove Selected Connection</button>
                </div>
            </div>

            <hr />

            <!-- Main Content Area (Collapsible Sections) -->
            <div id="main-content">
                <!-- Bucket Registration Section -->
                <details>
                    <summary><h2>Bucket Connection Registration</h2></summary>
                    <div>
                        <div class="form-group">
                            <h3>Register New Connection</h3>
                            <label for="regBucketName">Bucket Name:</label>
                            <input
                                type="text"
                                id="regBucketName"
                                placeholder="e.g., my-nail-images"
                                required
                            />

                            <label for="regAccessKeyId">AWS Access Key ID:</label>
                            <input
                                type="text"
                                id="regAccessKeyId"
                                placeholder="Your AWS Access Key ID"
                                required
                            />

                            <label for="regSecretAccessKey">AWS Secret Access Key:</label>
                            <input
                                type="password"
                                id="regSecretAccessKey"
                                placeholder="Your AWS Secret Access Key"
                                required
                            />

                            <label for="regRegion">Region:</label>
                            <input
                                type="text"
                                id="regRegion"
                                placeholder="e.g., us-west-1"
                                value="us-west-1"
                                required
                            />

                            <label for="regProvider">Provider:</label>
                            <input
                                type="text"
                                id="regProvider"
                                value="aws"
                                placeholder="e.g., aws, wasabi, backblaze"
                                required
                            />

                            <label for="regEndpointUrl"
                                >Endpoint URL
                                <span class="optional-label"
                                    >(Optional - for non-AWS S3 compatible)</span
                                >:</label
                            >
                            <input
                                type="url"
                                id="regEndpointUrl"
                                placeholder="e.g., https://s3.us-west-000.backblazeb2.com"
                            />

                            <button id="registerConnectionBtn">Register Connection</button>
                        </div>
                    </div>
                </details>

                <!-- Bucket Ingestion Section -->
                <details>
                    <summary><h2>Bucket Data Ingestion</h2></summary>
                    <div>
                        <p>Select a registered bucket connection above to start ingestion.</p>
                        <div class="form-group">
                            <label for="ingestCallbackUrl">Callback URL:</label>
                            <input
                                type="url"
                                id="ingestCallbackUrl"
                                placeholder="https://your-webhook-endpoint.com/notify"
                                value="https://webhook.site/"
                                required
                            />
                            <small>The API will POST status updates to this URL.</small>
                        </div>
                        <button id="startIngestionBtn" disabled>
                            Start Ingestion for Selected Connection
                        </button>
                    </div>
                </details>
            </div>
        </div>

        <!-- Status Indicator Element -->
        <div id="status-indicator"></div>

        <script>
            /**
             * =========================
             * CONFIGURATION CONSTANTS
             * =========================
             */

            /** @constant {string} The HTTP header name used for the API key. */
            const API_KEY_HEADER = "X-API-Key";
            /** @constant {number} Default duration (in milliseconds) to display status messages. */
            const STATUS_DISPLAY_DURATION = 4000;
            /** @constant {number} Duration (in milliseconds) to display error messages. */
            const ERROR_DISPLAY_DURATION = 6000;
            /** @constant {string[]} List of input element IDs whose values should be persisted in localStorage. */
            const PERSISTENT_INPUT_IDS = [
                "apiBaseUrlInput",
                "apiKeyInput",
                "regBucketName",
                "regAccessKeyId",
                "regSecretAccessKey",
                "regRegion",
                "regProvider",
                "regEndpointUrl",
                "ingestCallbackUrl",
            ];

            /**
             * =========================
             * DOM ELEMENT REFERENCES
             * =========================
             */
            const apiBaseUrlInput = document.getElementById("apiBaseUrlInput");
            const apiKeyInput = document.getElementById("apiKeyInput");
            // Connection Selection/Management Elements
            const bucketConnectionSelect = document.getElementById("bucketConnectionSelect");
            const refreshConnectionsBtn = document.getElementById("refreshConnectionsBtn");
            const removeConnectionBtn = document.getElementById("removeConnectionBtn");
            // Registration Form Elements
            const regBucketNameInput = document.getElementById("regBucketName");
            const regAccessKeyIdInput = document.getElementById("regAccessKeyId");
            const regSecretAccessKeyInput = document.getElementById("regSecretAccessKey");
            const regRegionInput = document.getElementById("regRegion");
            const regProviderInput = document.getElementById("regProvider");
            const regEndpointUrlInput = document.getElementById("regEndpointUrl");
            const registerConnectionBtn = document.getElementById("registerConnectionBtn");
            // Ingestion Form Elements
            const ingestCallbackUrlInput = document.getElementById("ingestCallbackUrl");
            const startIngestionBtn = document.getElementById("startIngestionBtn");
            // Status Indicator Element
            const statusIndicator = document.getElementById("status-indicator");
            /** @type {number | null} Timeout ID for the status indicator hide timer. */
            let statusTimeoutId = null;

            /**
             * =========================
             * HELPER FUNCTIONS
             * =========================
             */

            /**
             * Shows a status message overlay in the top-right corner of the screen.
             * @param {string} emoji - An emoji to prefix the message (e.g., "✅", "❌", "⚠️").
             * @param {string} message - The status message text to display.
             * @param {boolean} [isError=false] - If true, styles the indicator as an error message and uses a longer default duration.
             * @param {number} [duration=STATUS_DISPLAY_DURATION] - How long the message should be visible (ms). Overridden by ERROR_DISPLAY_DURATION if isError is true.
             * @returns {void}
             */
            function showStatusIndicator(
                emoji,
                message,
                isError = false,
                duration = STATUS_DISPLAY_DURATION,
            ) {
                if (statusTimeoutId) clearTimeout(statusTimeoutId); // Clear any existing timer
                const displayDuration = isError ? ERROR_DISPLAY_DURATION : duration;

                statusIndicator.innerHTML = `${emoji} ${message}`;
                statusIndicator.classList.toggle("error", isError);
                statusIndicator.classList.add("visible"); // Make it visible

                // Set a timer to hide the indicator
                statusTimeoutId = setTimeout(() => {
                    statusIndicator.classList.remove("visible");
                    // Clean up content after fade-out transition completes
                    setTimeout(() => {
                        if (!statusIndicator.classList.contains("visible")) {
                            statusIndicator.innerHTML = "";
                            statusIndicator.classList.remove("error");
                        }
                    }, 300); // Matches CSS transition duration
                    statusTimeoutId = null;
                }, displayDuration);
            }

            /**
             * Retrieves the API key from the input field. Shows a status indicator and returns null if missing.
             * @returns {string | null} The trimmed API key, or null if the input is empty.
             */
            function getApiKey() {
                const apiKey = apiKeyInput.value.trim();
                if (!apiKey) {
                    showStatusIndicator("⚠️", "API Key is required.", false, ERROR_DISPLAY_DURATION);
                    apiKeyInput.focus();
                    return null;
                }
                return apiKey;
            }

            /**
             * Retrieves the API Base URL from the input field. Shows a status indicator and returns null if missing or invalid.
             * @returns {string | null} The trimmed API base URL (without trailing slash), or null if the input is empty or not a valid URL.
             */
            function getApiBaseUrl() {
                const baseUrl = apiBaseUrlInput.value.trim();
                if (!baseUrl) {
                    showStatusIndicator(
                        "⚠️",
                        "API Base URL is required.",
                        false,
                        ERROR_DISPLAY_DURATION,
                    );
                    apiBaseUrlInput.focus();
                    return null;
                }
                try {
                    // Basic validation: check if it parses as a URL and has a protocol/host
                    const parsedUrl = new URL(baseUrl);
                    if (!parsedUrl.protocol || !parsedUrl.host) {
                        throw new Error("Incomplete URL");
                    }
                } catch (_) {
                    showStatusIndicator(
                        "⚠️",
                        "API Base URL is not a valid URL (e.g., https://example.com).",
                        false,
                        ERROR_DISPLAY_DURATION,
                    );
                    apiBaseUrlInput.focus();
                    return null;
                }
                // Return URL without trailing slash for consistency
                return baseUrl.replace(/\/$/, "");
            }

            /**
             * Handles errors from API calls, logging details and showing a user-friendly status message.
             * Attempts to parse error details from the Response body if available.
             * @param {Error | Response} error - The error object or Response object from a failed fetch.
             * @param {string} contextMessage - A message describing the context of the error (e.g., "Failed to list connections").
             * @returns {Promise<void>} Resolves after logging and showing the indicator.
             */
            async function handleApiError(error, contextMessage) {
                console.error(`${contextMessage}:`, error);
                let displayMessage = `${contextMessage}. Check console for details.`;

                // Attempt to extract more specific error message from Response object
                if (error instanceof Response) {
                    try {
                        const errorData = await error.json(); // Try parsing error JSON body
                        if (errorData.error && errorData.error.message) {
                            displayMessage = `${contextMessage}: ${errorData.error.message} (Status: ${error.status})`;
                        } else if (error.statusText) {
                            displayMessage = `${contextMessage}: ${error.status} ${error.statusText}.`;
                        } else {
                            displayMessage = `${contextMessage}: Received status ${error.status}.`;
                        }
                    } catch (parseError) {
                        // If JSON parsing fails, fallback to status code/text
                        console.warn("Failed to parse error response body:", parseError);
                        displayMessage = `${contextMessage}: Received status ${error.status}. Failed to parse details.`;
                    }
                } else if (error instanceof Error) {
                    // Handle standard JavaScript errors (e.g., network errors)
                    displayMessage = `${contextMessage}: ${error.message}`;
                }

                showStatusIndicator("❌", displayMessage, true, ERROR_DISPLAY_DURATION);
            }

            /**
             * Performs a generic fetch request to the NailedIT API.
             * Automatically includes the API key from the input field and constructs the full URL.
             * Handles basic request/response processing, including JSON parsing and error handling setup.
             * Sets the body cursor to 'wait' during the request.
             * @param {string} endpoint - The API endpoint path (e.g., "/buckets").
             * @param {RequestInit} [options={}] - Standard fetch options (method, body, etc.). Content-Type is added if not present and body is an object.
             * @returns {Promise<object|Response>} A promise that resolves to the parsed JSON response data, or the raw Response object for non-JSON/empty responses (like 204 No Content).
             * @throws {Error} Throws an error if the API Key or Base URL is missing/invalid, if the fetch fails (network error),
             *                 or if the response is not ok (forwarding the Response object for further processing),
             *                 or if JSON parsing fails on an expected JSON response.
             */
            async function fetchApi(endpoint, options = {}) {
                const apiKey = getApiKey();
                const baseUrl = getApiBaseUrl();

                if (!apiKey || !baseUrl) {
                    // Error messages are shown by getApiKey/getApiBaseUrl
                    // Ensure buttons reflect the invalid state before throwing
                    updateButtonStates();
                    throw new Error("API Key or Base URL is missing or invalid."); // Prevent fetch
                }

                // Construct URL and headers
                const url = `${baseUrl}${endpoint}`;
                const headers = {
                    ...(options.headers || {}),
                    [API_KEY_HEADER]: apiKey,
                    Accept: "application/json", // Prefer JSON responses
                };

                // Automatically set Content-Type for JSON if body is an object (and not FormData)
                if (
                    !(options.body instanceof FormData) &&
                    options.body != null &&
                    !headers["Content-Type"]
                ) {
                    headers["Content-Type"] = "application/json";
                }

                const fetchOptions = {
                    ...options,
                    headers,
                    mode: "cors", // Ensure CORS is enabled
                    cache: "no-cache", // Prevent caching of API responses
                };

                // Stringify body if it's an object (and not FormData)
                if (
                    typeof fetchOptions.body === "object" &&
                    !(fetchOptions.body instanceof FormData) &&
                    fetchOptions.body !== null
                ) {
                    fetchOptions.body = JSON.stringify(fetchOptions.body);
                }

                document.body.style.cursor = "wait"; // Indicate loading
                updateButtonStates(); // Update states reflecting the 'wait' cursor (disables buttons during request)

                try {
                    const response = await fetch(url, fetchOptions);

                    if (!response.ok) {
                        // Throw the response object itself for detailed error handling by handleApiError
                        throw response;
                    }

                    // Handle 204 No Content specifically - return the response object
                    if (response.status === 204) {
                        return response;
                    }

                    // Check Content-Type and length for other successful responses
                    const contentType = response.headers.get("content-type");
                    const contentLength = response.headers.get("content-length");

                    // If no content or not JSON, return the raw response object
                    if (
                        contentLength === "0" ||
                        !contentType ||
                        !contentType.includes("application/json")
                    ) {
                        console.warn(
                            `API returned status ${response.status} with non-JSON or empty response for endpoint: ${endpoint}`,
                        );
                        // Return the response object for status checking etc. in the caller
                        return response;
                    }

                    // Attempt to parse JSON if headers suggest it's present
                    try {
                        return await response.json();
                    } catch (e) {
                        console.error("Failed to parse JSON response:", e, response);
                        throw new Error(
                            "API returned invalid JSON response despite Content-Type header.",
                        );
                    }
                } finally {
                    document.body.style.cursor = "default"; // Reset cursor
                    updateButtonStates(); // Re-evaluate button states after API call completion or failure
                }
            }

            /**
             * Updates the enabled/disabled state of various buttons and the connection select dropdown
             * based on whether an API key/Base URL are present and a connection is selected.
             * Called after API calls, selection changes, or input changes.
             * @returns {void}
             */
            function updateButtonStates() {
                const connectionSelected = bucketConnectionSelect.value !== "";
                const apiKeyPresent = apiKeyInput.value.trim() !== "";
                const baseUrlPresent = apiBaseUrlInput.value.trim() !== "";
                const isApiCallInProgress = document.body.style.cursor === "wait";

                // Refresh button is enabled only if API key and Base URL are present, and not during an API call
                refreshConnectionsBtn.disabled =
                    !apiKeyPresent || !baseUrlPresent || isApiCallInProgress;

                // The select dropdown is disabled if there's no API key/Base URL, OR if an API call is in progress,
                // OR if there are no options other than the placeholder (length <= 1 AND first option value is "")
                const noValidOptions =
                    bucketConnectionSelect.options.length <= 1 &&
                    (bucketConnectionSelect.options.length === 0 ||
                        bucketConnectionSelect.options[0].value === "");
                bucketConnectionSelect.disabled =
                    !apiKeyPresent || !baseUrlPresent || isApiCallInProgress || noValidOptions;

                // Enable remove/start only if a connection is selected AND key/URL are present AND no API call in progress
                const canInteractWithSelected =
                    connectionSelected && apiKeyPresent && baseUrlPresent && !isApiCallInProgress;
                removeConnectionBtn.disabled = !canInteractWithSelected;
                startIngestionBtn.disabled = !canInteractWithSelected;

                // Registration button should generally be enabled unless an API call is in progress.
                registerConnectionBtn.disabled = isApiCallInProgress;
            }

            /**
             * =========================
             * LOCAL STORAGE FUNCTIONS (Persistence)
             * =========================
             */

            /**
             * Saves the value of an input field to localStorage.
             * @param {string} inputId - The ID of the input element.
             * @param {string} value - The value to save.
             * @returns {void}
             */
            function saveSetting(inputId, value) {
                try {
                    localStorage.setItem(inputId, value);
                } catch (e) {
                    console.warn("Could not save setting to localStorage:", e);
                }
            }

            /**
             * Loads persisted settings from localStorage into their corresponding input fields.
             * Attempts to list connections automatically if both API key and Base URL are found.
             * Also attempts to ping the API if the Base URL is found.
             * @returns {void}
             */
            function loadSettings() {
                PERSISTENT_INPUT_IDS.forEach((id) => {
                    const savedValue = localStorage.getItem(id);
                    const inputElement = document.getElementById(id);
                    if (savedValue !== null && inputElement) {
                        inputElement.value = savedValue;
                    }
                });

                // Special handling for API key & Base URL: trigger connection list and ping if both exist
                const savedApiKey = localStorage.getItem("apiKeyInput");
                const savedBaseUrl = localStorage.getItem("apiBaseUrlInput");
                // Call updateButtonStates *before* potentially starting async calls
                // to set initial state based on loaded values.
                updateButtonStates();

                if (savedApiKey && savedBaseUrl) {
                    console.log("API Key & Base URL found in storage, attempting actions...");
                    // Start listing connections (asynchronous)
                    listBucketConnections(false); // false = don't show status indicator just for initial load

                    // Start ping in the background (fire-and-forget, no await)
                    pingIngestApi();
                } else {
                    // Ensure placeholder is correct if key/URL are missing on load
                    bucketConnectionSelect.innerHTML =
                        '<option value="">-- Enter API Key & Base URL First --</option>';
                    updateButtonStates(); // Re-run to ensure select is disabled correctly
                }
                // Note: updateButtonStates is called again within listBucketConnections/fetchApi finally block
            }

            /**
             * Attaches 'change' event listeners to persistent input fields to save their values automatically.
             * If API key or Base URL changes, it triggers an update of button states and a refresh of the bucket list.
             * @returns {void}
             */
            function setupPersistenceListeners() {
                PERSISTENT_INPUT_IDS.forEach((id) => {
                    const inputElement = document.getElementById(id);
                    if (inputElement) {
                        inputElement.addEventListener("change", (event) => {
                            const target = event.target;
                            saveSetting(target.id, target.value);
                            // If API key or Base URL changed, update button states and attempt refresh
                            if (target.id === "apiKeyInput" || target.id === "apiBaseUrlInput") {
                                // *** FIX: Call updateButtonStates immediately after change ***
                                // This ensures buttons like 'Refresh' enable as soon as both fields are filled,
                                // even before the listConnections API call completes.
                                updateButtonStates();

                                // Refresh list quietly without success indicator
                                listBucketConnections(false);
                                // Also try pinging again on URL/Key change
                                pingIngestApi();
                            }
                        });
                    }
                });
            }

            /**
             * =========================
             * API INTERACTION FUNCTIONS
             * =========================
             */

            /**
             * Sends a ping request to the API's /ping-ingest endpoint.
             * Logs success to the console and shows a status indicator on failure.
             * Does nothing if the Base URL is not set.
             * @returns {Promise<void>}
             */
            async function pingIngestApi() {
                // Use getApiBaseUrl for validation consistency, but don't block if it returns null initially
                const baseUrl = apiBaseUrlInput.value.trim(); // Quick check
                if (!baseUrl) {
                    console.log("Skipping API ping: Base URL not set.");
                    return;
                }

                console.log("Attempting API ping...");
                try {
                    // fetchApi handles base URL, key (if present), headers, method, basic fetch logic
                    // Note: This will send the API key header if an API key is present in the input.
                    const responsePromise = fetchApi("/ping-ingest", { method: "GET" });

                    // Handle the promise outcome without blocking
                    responsePromise
                        .then((response) => {
                            // Check if the response status is OK (e.g., 200)
                            // fetchApi returns the Response object for non-JSON/empty or 204 responses
                            if (response instanceof Response && response.ok) {
                                console.log(`API Ping Successful (Status: ${response.status}).`);
                                // Optional: Show a brief success indicator if needed
                                // showStatusIndicator("✅", "API Ping OK", false, 2000);
                            } else if (
                                typeof response === "object" &&
                                response !== null &&
                                !(response instanceof Response)
                            ) {
                                // Handle case where fetchApi successfully parsed JSON (might be unexpected for a simple ping)
                                console.log("API Ping Successful (Received JSON data):", response);
                            }
                            // If fetchApi threw an error (non-ok response), it will be caught below.
                            // If fetchApi returned something unexpected, log it.
                            else if (!(response instanceof Response)) {
                                console.warn("Unexpected response type from ping:", response);
                            }
                            // No explicit failure case here for non-ok that wasn't thrown, though fetchApi usually throws.
                        })
                        .catch((error) => {
                            // handleApiError will show a status indicator
                            // This catch block handles errors from the fetchApi call itself (e.g., network error, non-ok response)
                            handleApiError(error, "API Ping Failed");
                        });
                } catch (error) {
                    // This catch block handles immediate errors *before* the async fetch starts
                    // (e.g., if getApiKey or getApiBaseUrl fail synchronously within fetchApi).
                    // Most errors (network, non-ok status) will be caught by the .catch() above.
                    handleApiError(error, "API Ping Failed (Initial Setup)");
                }
                // Note: updateButtonStates() is NOT called here to avoid interfering with other ongoing operations.
                // The ping is meant to be non-blocking. Button states are updated by fetchApi's finally block.
            }

            /**
             * Registers a new S3 bucket connection configuration via the API.
             * Reads connection details from the registration form inputs.
             * @returns {Promise<void>} Resolves after the registration attempt (success or failure).
             */
            async function registerConnection() {
                // API Key and Base URL are checked within fetchApi
                const bucketName = regBucketNameInput.value.trim();
                const accessKeyId = regAccessKeyIdInput.value.trim();
                const secretAccessKey = regSecretAccessKeyInput.value.trim();
                const region = regRegionInput.value.trim();
                const provider = regProviderInput.value.trim();
                const endpointUrl = regEndpointUrlInput.value.trim() || null; // Use null if empty

                // Basic client-side validation
                if (!bucketName || !accessKeyId || !secretAccessKey || !region || !provider) {
                    showStatusIndicator(
                        "⚠️",
                        "Please fill in all required connection registration fields.",
                        false,
                        ERROR_DISPLAY_DURATION,
                    );
                    return;
                }

                const body = {
                    aws_access_key_id: accessKeyId,
                    aws_secret_access_key: secretAccessKey,
                    region: region,
                    provider: provider,
                    // Conditionally include endpoint_url only if it has a value
                    ...(endpointUrl && { endpoint_url: endpointUrl }),
                };

                // Button disabling is handled by fetchApi's state updates via updateButtonStates
                // registerConnectionBtn.disabled = true;

                try {
                    const endpoint = `/buckets/${encodeURIComponent(bucketName)}`;
                    // fetchApi handles key/base URL checks and base fetch logic
                    const result = await fetchApi(endpoint, { method: "POST", body });

                    // Check for successful registration (expecting JSON with data.name or a successful Response)
                    if (result && result.data && result.data.name) {
                        showStatusIndicator(
                            "✅",
                            `Connection for '${result.data.name}' registered. Refreshing list...`,
                        );
                        await listBucketConnections(false); // Refresh list without indicator
                        // Optional: Clear sensitive fields after success
                        // regAccessKeyIdInput.value = ''; saveSetting('regAccessKeyId', '');
                        // regSecretAccessKeyInput.value = ''; saveSetting('regSecretAccessKey', '');
                    } else if (result instanceof Response && result.ok) {
                        // Handle cases like 201 Created where response might not have expected JSON body
                        showStatusIndicator(
                            "✅",
                            `Connection for '${bucketName}' registered (Status: ${result.status}). Refreshing list...`,
                        );
                        await listBucketConnections(false);
                    } else {
                        // If result is neither expected JSON nor a successful Response object
                        console.warn("Unexpected response format after registration:", result);
                        throw new Error("Unexpected response format after registration.");
                    }
                } catch (error) {
                    handleApiError(error, "Failed to register connection");
                } finally {
                    // Button states are updated by fetchApi's finally block
                }
            }

            /**
             * Fetches the list of registered bucket connections from the API and populates the dropdown select element.
             * Handles various response scenarios including success, no connections, and errors.
             * @param {boolean} [showIndicator=true] - Whether to show a success/info status indicator upon completion. Errors always show an indicator.
             * @returns {Promise<void>} Resolves after attempting to list connections and update the UI.
             */
            async function listBucketConnections(showIndicator = true) {
                // Pre-flight check for API key/URL before making the call
                const apiKey = apiKeyInput.value.trim();
                const baseUrl = apiBaseUrlInput.value.trim();

                if (!apiKey || !baseUrl) {
                    // Update UI to reflect missing credentials
                    bucketConnectionSelect.innerHTML =
                        '<option value="">-- Enter API Key & Base URL First --</option>';
                    if (
                        showIndicator &&
                        (document.activeElement === apiKeyInput ||
                            document.activeElement === apiBaseUrlInput ||
                            document.activeElement === refreshConnectionsBtn) // Show indicator if manually refreshed
                    ) {
                        // Only show indicator if user likely interacted with key/URL inputs recently or clicked refresh
                        showStatusIndicator(
                            "⚠️",
                            "API Key and Base URL are required to list connections.",
                            false,
                            ERROR_DISPLAY_DURATION,
                        );
                    }
                    updateButtonStates(); // Ensure buttons/select reflect missing key/URL
                    return; // Don't proceed with API call
                }

                // Update UI state for loading
                bucketConnectionSelect.innerHTML = '<option value="">-- Loading... --</option>';
                // Disabling is handled by fetchApi via updateButtonStates
                // bucketConnectionSelect.disabled = true;
                // updateButtonStates(); // Update other button states (fetchApi will do this too)

                try {
                    // fetchApi handles key/base URL, headers, and basic fetch logic
                    // It also handles button states during the request
                    const result = await fetchApi("/buckets", { method: "GET" });

                    // Process successful response (expecting JSON with data.results array)
                    if (result && result.data && Array.isArray(result.data.results)) {
                        const bucketNames = result.data.results;
                        bucketConnectionSelect.innerHTML = ""; // Clear loading message

                        if (bucketNames.length === 0) {
                            bucketConnectionSelect.innerHTML =
                                '<option value="">-- No connections registered --</option>';
                            if (showIndicator)
                                showStatusIndicator(
                                    "ℹ️",
                                    "No connections registered for this API key.",
                                );
                        } else {
                            // Add placeholder and then connection options
                            bucketConnectionSelect.innerHTML =
                                '<option value="">-- Select a Connection --</option>';
                            bucketNames.forEach((bucketName) => {
                                const option = document.createElement("option");
                                option.value = bucketName;
                                option.textContent = bucketName;
                                bucketConnectionSelect.appendChild(option);
                            });
                            if (showIndicator)
                                showStatusIndicator(
                                    "✅",
                                    `Found ${bucketNames.length} connection(s).`,
                                );
                        }
                    }
                    // Handle cases where API returns successful status but not the expected JSON format (e.g., empty 200 OK)
                    else if (result instanceof Response && result.ok) {
                        bucketConnectionSelect.innerHTML =
                            '<option value="">-- No connections registered --</option>';
                        if (showIndicator)
                            showStatusIndicator(
                                "ℹ️",
                                "No connections found (empty success response).",
                            );
                        console.warn(
                            "Received successful but non-standard response listing connections:",
                            result,
                        );
                    }
                    // Handle cases where result is neither expected JSON nor a successful Response
                    else {
                        bucketConnectionSelect.innerHTML =
                            '<option value="">-- Error: Invalid response --</option>';
                        if (showIndicator)
                            showStatusIndicator(
                                "⚠️",
                                "Received invalid data listing connections.",
                                false,
                                ERROR_DISPLAY_DURATION,
                            );
                        console.warn("Unexpected response format when listing connections:", result);
                    }
                } catch (error) {
                    // Handle specific HTTP errors (like 401/403/404) potentially indicating bad key/URL or no connections
                    if (
                        error instanceof Response &&
                        (error.status === 401 || error.status === 403 || error.status === 404)
                    ) {
                        bucketConnectionSelect.innerHTML =
                            '<option value="">-- No connections found / Invalid Credentials --</option>';
                        if (showIndicator)
                            showStatusIndicator(
                                "ℹ️",
                                `No connections found or invalid credentials (Status: ${error.status}).`,
                                false,
                                ERROR_DISPLAY_DURATION,
                            );
                        // No need to call handleApiError here as it's a handled scenario
                    } else {
                        // Handle other errors (network errors, unexpected server errors, JSON parse errors from fetchApi)
                        handleApiError(error, "Failed to list connections");
                        bucketConnectionSelect.innerHTML =
                            '<option value="">-- Error loading connections --</option>';
                    }
                } finally {
                    // Always re-evaluate button and select states after the attempt
                    // fetchApi's finally block already calls updateButtonStates()
                    updateButtonStates(); // Call again explicitly to ensure state after populating/clearing select
                }
            }

            /**
             * Removes the registration for the currently selected bucket connection via the API.
             * Prompts the user for confirmation before proceeding.
             * @returns {Promise<void>} Resolves after the removal attempt.
             */
            async function removeConnection() {
                // API Key and Base URL checked implicitly by fetchApi
                const selectedBucket = bucketConnectionSelect.value;
                if (!selectedBucket) {
                    showStatusIndicator(
                        "⚠️",
                        "Please select a connection to remove.",
                        false,
                        ERROR_DISPLAY_DURATION,
                    );
                    return;
                }

                // User confirmation
                if (
                    !confirm(
                        `Are you sure you want to remove the connection registration for bucket '${selectedBucket}'? This action cannot be undone.`,
                    )
                ) {
                    return;
                }

                // Button disabling is handled by fetchApi via updateButtonStates
                // removeConnectionBtn.disabled = true;
                // startIngestionBtn.disabled = true;

                try {
                    const endpoint = `/buckets/${encodeURIComponent(selectedBucket)}`;
                    // fetchApi handles key/base URL, headers, method etc. and button states
                    const response = await fetchApi(endpoint, { method: "DELETE" });

                    // DELETE often returns 204 No Content on success
                    if (response instanceof Response && response.status === 204) {
                        showStatusIndicator(
                            "✅",
                            `Connection registration '${selectedBucket}' removed.`,
                        );
                        // Remove the option from the dropdown
                        const optionToRemove = bucketConnectionSelect.querySelector(
                            `option[value="${selectedBucket}"]`,
                        );
                        if (optionToRemove) optionToRemove.remove();

                        // Reset selection and update placeholder if the list becomes empty
                        bucketConnectionSelect.value = "";
                        if (
                            bucketConnectionSelect.options.length <= 1 &&
                            (bucketConnectionSelect.options.length === 0 ||
                                bucketConnectionSelect.options[0].value === "")
                        ) {
                            // Check if only placeholder or nothing is left
                            bucketConnectionSelect.innerHTML =
                                '<option value="">-- No connections registered --</option>';
                        }
                        // Update states explicitly here after modifying select options
                        updateButtonStates();
                    } else {
                        // Handle unexpected success responses (e.g., 200 OK on DELETE)
                        console.warn(
                            "Received unexpected response type/status after DELETE:",
                            response,
                        );
                        if (response instanceof Response && response.ok) {
                            showStatusIndicator(
                                "✅",
                                `Connection registration '${selectedBucket}' removal initiated (Status: ${response.status}). Refreshing list...`,
                            );
                            await listBucketConnections(false); // Refresh list to confirm removal
                        } else {
                            // Throw an error if the response wasn't technically 'ok' or wasn't a Response object
                            throw new Error(
                                `Unexpected status (${response?.status}) or response format during removal.`,
                            );
                        }
                    }
                } catch (error) {
                    handleApiError(error, `Failed to remove connection '${selectedBucket}'`);
                    // Button states will be updated by fetchApi's finally block
                } finally {
                    // Re-evaluate button states after the operation completes.
                    // fetchApi's finally block already does this.
                    updateButtonStates(); // Call again explicitly after potential select manipulation
                }
            }

            /**
             * Initiates the data ingestion process for the selected bucket connection via the API.
             * Sends the provided callback URL for status updates.
             * @returns {Promise<void>} Resolves after the ingestion start request attempt.
             */
            async function startIngestion() {
                // API Key and Base URL checked implicitly by fetchApi
                const selectedBucket = bucketConnectionSelect.value;
                if (!selectedBucket) {
                    showStatusIndicator(
                        "⚠️",
                        "Please select a connection to start ingestion.",
                        false,
                        ERROR_DISPLAY_DURATION,
                    );
                    return;
                }

                // Validate callback URL
                const callbackUrl = ingestCallbackUrlInput.value.trim();
                if (!callbackUrl) {
                    showStatusIndicator(
                        "⚠️",
                        "Callback URL is required for status updates.",
                        false,
                        ERROR_DISPLAY_DURATION,
                    );
                    ingestCallbackUrlInput.focus();
                    return;
                }
                try {
                    new URL(callbackUrl); // Basic URL validation
                } catch (_) {
                    showStatusIndicator(
                        "⚠️",
                        "The Callback URL is not valid.",
                        false,
                        ERROR_DISPLAY_DURATION,
                    );
                    ingestCallbackUrlInput.focus();
                    return;
                }

                // Button disabling is handled by fetchApi via updateButtonStates
                // startIngestionBtn.disabled = true;
                // removeConnectionBtn.disabled = true;

                const body = { callback_url: callbackUrl };

                try {
                    const endpoint = `/buckets/${encodeURIComponent(selectedBucket)}/ingest`;
                    // fetchApi handles key/base URL, headers, method, body stringification etc. and button states
                    const result = await fetchApi(endpoint, { method: "POST", body });

                    // Expecting JSON like {"data": {"status": "...", ...}} on success (e.g., 202 Accepted)
                    if (result && result.data && result.data.status) {
                        showStatusIndicator(
                            "✅",
                            `Ingestion started for '${selectedBucket}'. Status: ${result.data.status}.`,
                        );
                    }
                    // Handle alternative success responses like 202 Accepted without specific JSON body
                    else if (result instanceof Response && result.ok) {
                        // Common case: API returns 202 Accepted without a detailed body immediately
                        showStatusIndicator(
                            "✅",
                            `Ingestion request accepted for '${selectedBucket}' (Status: ${result.status}). Check callback URL for updates.`,
                        );
                        console.log(
                            "Received successful but potentially non-JSON response starting ingestion:",
                            result,
                        );
                    }
                    // Handle unexpected response format on success
                    else {
                        console.warn("Unexpected response format after starting ingestion:", result);
                        throw new Error("Unexpected response format after starting ingestion.");
                    }
                } catch (error) {
                    handleApiError(error, `Failed to start ingestion for '${selectedBucket}'`);
                    // Button states will be updated by fetchApi's finally block
                } finally {
                    // Re-evaluate button states after the operation completes.
                    // fetchApi's finally block already does this.
                    updateButtonStates();
                }
            }

            /**
             * =========================
             * INITIALIZATION & EVENT LISTENERS
             * =========================
             */

            /**
             * Initializes the dashboard by setting up event listeners and loading persisted settings.
             * @listens DOMContentLoaded
             */
            document.addEventListener("DOMContentLoaded", () => {
                // Assign primary button actions
                registerConnectionBtn.onclick = registerConnection;
                refreshConnectionsBtn.onclick = () => listBucketConnections(true); // Show indicator on manual refresh
                removeConnectionBtn.onclick = removeConnection;
                startIngestionBtn.onclick = startIngestion;

                // Update button states when connection selection changes
                bucketConnectionSelect.onchange = updateButtonStates;

                // Setup listeners to persist input values AND trigger updates
                setupPersistenceListeners();

                // Load previously saved settings from localStorage
                // This also triggers initial listBucketConnections and pingIngestApi if key/URL exist
                loadSettings();

                // Perform an initial update of button states after loading potentially saved data
                // Note: loadSettings() now calls updateButtonStates() itself appropriately.
                // updateButtonStates();
            });
        </script>
    </body>
</html>
